Function: fork
----------------------------------

#### syntax: (fork *exp*)

The expression in *exp* is launched as a newLISP child process-thread of
the platforms OS. The new process inherits the entire address space, but
runs independently so symbol or variable contents changed in the child
process will not affect the parent process or vice versa. The child
process ends when the evaluation of *exp* finishes.

On success, `fork` returns with the child process ID; on failure, `nil`
is returned. See also the [wait-pid](#wait-pid) function, which waits
for a child process to finish.

This function is only available on Linux/Unix versions of newLISP and is
based on the `fork()` implementation of the underlying OS.

A much simpler automated method to launch processes and collect results
is available with [spawn](#spawn) and the [Cilk API](#cilk).

    > (set 'x 0)
    0
    > (fork (while (< x 20) (println (inc x)) (sleep 1000)))
    176

    > 1
    2
    3
    4
    5
    6

The example illustrates how the child process-thread inherits the symbol
space and how it is independent of the parent process. The `fork`
statement returns immediately with the process ID `176`. The child
process increments the variable `x` by one each second and prints it to
standard out (boldface). In the parent process, commands can still be
entered. Type `x` to see that the symbol `x` still has the value `0`
(zero) in the parent process. Although statements entered will mix with
the display of the child process output, they will be correctly input to
the parent process.

The second example illustrates how [pipe](#pipe) can be used to
communicate between processes.

    #!/usr/bin/newlisp

    (define (count-down-proc x channel)
      (while (!= x 0)
          (write-line channel (string x))
          (dec x)))

    (define (observer-proc channel)
      (do-until (= i "1")
        (println "process " (setq i (read-line channel)))))

    (map set '(in out) (pipe))
    (set 'observer (fork (observer-proc in)))
    (set 'counter (fork (count-down-proc 5 out)))

    ; avoid zombies
    (wait-pid observer)
    (wait-pid counter)

    (exit)

The following output is generated by observer-proc

    process 5
    process 4
    process 3
    process 2
    process 1

The `count-down-proc` writes numbers to the communication pipe, where
they are picked up by the `observer-process` and displayed.

A forked process can either exit by itself or it can be destroyed using
the [destroy](#destroy) function.

    (define (fork-destroy-demo)
        (set 'pid (fork (dotimes (i 1000) (println i) (sleep 10))))
        (sleep 50)
        (destroy pid) 
    )

    > (fork-destroy-demo)
    0
    1
    2
    3
    4
    true
    > 

The process started by `fork-destroy-demo` will not finish but is
destroyed 50 milli-seconds after start by a call to [destroy](#destroy).

Use the [semaphore](#semaphore) function for synchronizing processes and
[share](#share) for sharing memory between processes.

See [spawn](#spawn) for a much simpler and automated way to synchronize
processes and collect results.


